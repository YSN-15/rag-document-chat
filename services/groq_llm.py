import json
import logging
import requests
from config import Config

logger = logging.getLogger(__name__)

class GroqLLMService:
    def __init__(self):
        self.api_key = Config.GROQ_API_KEY
        if not self.api_key:
            raise ValueError("GROQ API key not configured")
        
        self.base_url = "https://api.groq.com/openai/v1"
        self.model = "llama-3.1-70b-versatile"  # Using Llama 3.1 model
        
        self.system_prompt = """
You are a helpful assistant that answers questions based on the provided document context.
Always cite your sources by referencing the document name and page number.
If the context doesn't contain relevant information, say so clearly.
Be concise but thorough in your responses.
Format your citations as [Document: filename.pdf, Page: X].
"""
    
    def generate_response_from_context(self, user_query, context, sources):
        """
        Generate response using GROQ LLM based on search results
        """
        try:
            # Construct the user prompt with the provided context
            user_prompt = f"""
Context from documents:
{context}

Question: {user_query}

Please provide a comprehensive answer based on the context above. Include specific citations by mentioning the document names.
"""
            
            # Prepare the API request
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            payload = {
                "model": self.model,
                "messages": [
                    {"role": "system", "content": self.system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                "temperature": 0.1,
                "max_tokens": 1024,
                "top_p": 1,
                "stream": False
            }
            
            # Make the API request
            response = requests.post(
                f"{self.base_url}/chat/completions",
                headers=headers,
                json=payload,
                timeout=30
            )
            
            if response.status_code != 200:
                logger.error(f"GROQ API error: {response.status_code} - {response.text}")
                raise Exception(f"GROQ API request failed: {response.status_code}")
            
            result = response.json()
            
            if 'choices' not in result or not result['choices']:
                raise Exception("No response generated by GROQ")
            
            generated_response = result['choices'][0]['message']['content']
            
            logger.info(f"Generated response for query: {user_query[:50]}...")
            
            return {
                "response": generated_response,
                "sources": sources,
                "context_used": len(sources)
            }
            
        except requests.exceptions.Timeout:
            logger.error("GROQ API request timed out")
            raise Exception("Request timed out. Please try again.")
        except requests.exceptions.RequestException as e:
            logger.error(f"GROQ API request error: {str(e)}")
            raise Exception(f"Failed to connect to GROQ API: {str(e)}")
        except Exception as e:
            logger.error(f"Error generating response: {str(e)}")
            raise
    
    def _build_context(self, search_results):
        """
        Build context string from search results
        """
        context_parts = []
        
        for i, result in enumerate(search_results, 1):
            content = result['content']
            doc_name = result['document_name']
            page_num = result.get('page_number', 'Unknown')
            section = result.get('section', '')
            
            context_part = f"""
Source {i}:
Document: {doc_name}
Page: {page_num}
{f"Section: {section}" if section else ""}
Content: {content}
---
"""
            context_parts.append(context_part)
        
        return "\n".join(context_parts)
    
    def _extract_sources(self, search_results):
        """
        Extract source information for citation
        """
        sources = []
        seen_sources = set()
        
        for result in search_results:
            source_key = f"{result['document_name']}_{result.get('page_number', 1)}"
            if source_key not in seen_sources:
                sources.append({
                    "document_name": result['document_name'],
                    "page_number": result.get('page_number', 1),
                    "section": result.get('section', ''),
                    "relevance_score": result.get('score', 0)
                })
                seen_sources.add(source_key)
        
        return sources
    
    def generate_summary(self, document_content, document_name):
        """
        Generate a summary of a document
        """
        try:
            summary_prompt = f"""
Please provide a concise summary of the following document content from {document_name}:

{document_content[:4000]}  # Limit content to avoid token limits

Summary should be 2-3 paragraphs highlighting the main topics and key information.
"""
            
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            payload = {
                "model": self.model,
                "messages": [
                    {"role": "system", "content": "You are a helpful assistant that creates concise document summaries."},
                    {"role": "user", "content": summary_prompt}
                ],
                "temperature": 0.3,
                "max_tokens": 300,
                "top_p": 1,
                "stream": False
            }
            
            response = requests.post(
                f"{self.base_url}/chat/completions",
                headers=headers,
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                if 'choices' in result and result['choices']:
                    return result['choices'][0]['message']['content']
            
            return "Summary generation failed"
            
        except Exception as e:
            logger.error(f"Error generating summary: {str(e)}")
            return "Summary not available"
